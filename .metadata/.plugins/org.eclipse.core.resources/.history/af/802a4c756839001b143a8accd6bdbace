/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include"bits.h"

void delay(void);

int main(void)
{
	RCC_AHB1ENR_t *p_rcc 	= (RCC_AHB1ENR_t *)(0x40023800 + 0x30);

	GPIO_MODER_t *gpio_b 	= (GPIO_MODER_t *)(0x40020400);
	GPIO_MODER_t *gpio_c	= (GPIO_MODER_t *)(0x40020800);

	GPIO_ODR_t *odr_b 		= (GPIO_ODR_t *)(0x40020400 + 0x14);
	uint32_t *odr_bi		= (uint32_t *)(0x40020400 + 0x14);
	GPIO_IDR_t *idr_c		= (GPIO_IDR_t *)(0x40020800 + 0x10);

	GPIO_PUPDR_t *pud_c		= (GPIO_PUPDR_t *)(0x40020800 + 0x0C);


	p_rcc ->gpioB_en = 1;
	p_rcc ->gpioC_en = 1;

#if 1
	gpio_b ->mode_r0 = 1;
	gpio_b ->mode_r1 = 1;
	gpio_b ->mode_r2 = 1;
	gpio_b ->mode_r3 = 1;
	gpio_b ->mode_r4 = 1;
	gpio_b ->mode_r5 = 1;
	gpio_b ->mode_r6 = 1;
	gpio_b ->mode_r7 = 1;

	gpio_c ->mode_r13 = 0;
#endif

	pud_c ->pupdr4 = 1;

	int var = 0;
	while(1){
		if(((idr_c ->idr4) == 0))
		{
			var++;
			*odr_bi &= 0;
		}

		switch(var)
		{
		case 1 :	odr_b ->od_r0 ^= 1;
					delay();
					odr_b ->od_r1 ^= 1;
					delay();
					odr_b ->od_r2 ^= 1;
					delay();
					odr_b ->od_r3 ^= 1;
					delay();
					odr_b ->od_r4 ^= 1;
					delay();
					odr_b ->od_r5 ^= 1;
					delay();
					odr_b ->od_r6 ^= 1;
					delay();
					odr_b ->od_r7 ^= 1;
					delay();
					break;

		case 2 :    odr_b ->od_r0 ^= 1;
					odr_b ->od_r2 ^= 1;
					odr_b ->od_r4 ^= 1;
					odr_b ->od_r6 ^= 1;
					delay();
					odr_b ->od_r1 ^= 1;
					odr_b ->od_r3 ^= 1;
					odr_b ->od_r5 ^= 1;
					odr_b ->od_r7 ^= 1;
					break;

		case 3 :	*odr_bi += 1;
					delay();
					break;
		}

		if(var > 3) var = 0;
	}

}
